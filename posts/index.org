#+TITLE: DWIM
#+ORGA_PUBLISH_KEYWORD: PUBLISHED
#+TODO: DRAFT(d) | PUBLISHED(p) CANCELLED(c)


* DRAFT Software development is a craft                                  :it:

It is not a science (yet)
Learn through master/apprentice

* DRAFT Work vs problems                                       :productivity:

I distinguish between work and problems.

Work can be done by following well-known, accepted rules. It may not be easy, but you know from the start how hard it is and how much effort it takes. Work just takes time, energy and commitment. So, just do it already!

There are no predefined rules for problems. You have to figure them out as you go along. It's not even clear how to know which solution is best, because problems usually have multiple perspectives with (possibly conflicting) interests. Problems may even have multiple stakeholders. So you have to analyze the problem to come up with possible solutions, evaluate the solutions by all different criteria, and than choose on basis of incomplete information. And that's all /before/ you can start actually solving them problem itself.

The obvious trap here is that you can get stuck in the analysis/evaluation, because choosing is hard and often involves conflict. So my approach often is to just choose one option, fix the problem and deal with the consequences. Which may involve a whole new solution. I am happy to solve a problem more than once, because it means you always have a solution in place (as imperfect as it may be), and it will gradually get better.

* DRAFT Yesterbox                                              :productivity:

https://yesterbox.com/

Slow cooking, slow communication

* DRAFT When in doubt                                                 :emacs:

Stay on the same road

Emacs:
- one customization/keys section, or many
- literate programming, or comments

If it's not broken, don't fix it :it:


* PUBLISHED What is Org mode                                            :org:
CLOSED: [2020-02-07 vr 09:23]

So I wrote about how to [[10 minute org mode 101][use]] Org mode, but only briefly discussed what it /is/:

#+BEGIN_QUOTE
Org mode is a fast and effective tool to manage personal information, like notes, tasks, and references. It is also used for authoring and publishing blogs, books and academic papers. Org mode is part of Emacs and stores its data in plain-text files.
#+END_QUOTE

That's not a lie, but it barely scratches the surface. I was listening to [[https://emacscast.org/episode_3/][Emacscast]] today, and the explanation by host Rakhim inspired this post.

Basically, I see Org mode as three parts:

- a markup language :: The markup language supports structuring with nested sections and formatting like for example Markdown. Unlike Markdown, and more like XML, org mode also supports meta data, like categories, tags, and properties
- an editor :: Org mode is part of Emacs, so when editing org mode, you can use all functions that Emacs provides. But it adds powerful features to manage complexity, like outlining, navigating, folding and tables.
- modules :: Org mode provides a myriad of modules out of the box, including, but definitely not limited to:
  - todos: Keep your task list with todo states, priorities, deadlines and scheduling.
  - agenda: Manage your tasks by sorting and filtering them in any way you can think of.
  - spreadsheet: Interactively calculate values in a table.
  - publish: Edit your content in org mode, and publish it as Markdown, HTML, PDF or EPUB out of the box, or [[https://github.com/kawabata/ox-pandoc][any other form]] via Pandoc.
  - literate programming: Execute code right in your document with Babel.
  - capture thoughts: With minimal disruption to your workflow.
  - time management: Estimate, register and report how you spend uour time.

As the markup is just plain text, you can edit org mode files in any text editor you like. This ensures you never loose access to your data. The editor is where org mode begins to distinguish itself: editors like [[https://github.com/vscode-org-mode/vscode-org-mode][VSCode]], [[https://github.com/jceb/vim-orgmode][Vim]] and [[https://packagecontrol.io/packages/orgmode][Sublime]] support only a small subset of the features you get when editing org mode in Emacs. But the modules are where org mode really starts to shine. They add such amazingly powerful features that they make org mode unlike any other tool I know.

The strength of these modules is that they are +integrated+ loosely coupled. By that I mean they have maximum cohesion and minimum dependency. And by that I mean that the modules form a suite where every tool works together with the others, but the do not /need/ each other. This way you can gradually add modules to get an ever richer experience and truly [[http://doc.norang.ca/org-mode.html][Organize Your Life In Plain Text!]]

* PUBLISHED Peter Principle for assholes                       :organisation:
CLOSED: [2020-02-06 do 08:38]

The [[https://en.wikipedia.org/wiki/Peter_principle][Peter Principle]] states:

#+BEGIN_QUOTE
  people in a hierarchy tend to rise to their "level of incompetence"
#+END_QUOTE

It boils down to this: when you are competent at your job, you are promoted until you're /not/ competent anymore.

But I think something more sinister is at play here. In [[http://www.dilbert.com/][The Dilbert Principle]] Scott Adams suggests that the main task of management is to "Eliminate the Assholes". However, my view is that management /are/ the assholes. Nothing personal, so let me explain.

We are all constantly working for (1) our own position and (2) the higher good. Working for our own position may mean making our work as enjoyable as possible, maximizing status/income/power, or anything that you want to achieve for yourself. The higher good is the reason your job exists in the first place: the business of your customers, some political ideal, or a charity.

Most people most of the time look for a middle ground between their own position and the higher good. They try to strike a balance where the one not does not harm the other. But sometimes this doesn't work and you have to make a choice. For example, if you stand up for an important but unpopular policy, it may help the higher good, but it may harm your position.

This also works in unexpected ways. For example, if you work late to provide a critical feature for your client before its deadline, you would think this would help both the higher good and your position. But the latter is rarely the case. We are often not rewarded for extra effort we put in. Why is this?

I think this is because some people do /not/ balance their own position and the higher good, but instead choose just one of these. In particular, some people focus exclusively on their own position, and work for their own promotion only. So in the contest for income, status or power, these people win from anyone who divide their focus between their position and the higher good.

It is just as in sports: to really make it to the top, you have to sacrifice everything and everyone and put all your effort into becoming the best you can be at your chosen sport. This doesn't mean success is guaranteed if you do that (in fact, chances are remote), because others who do the same may have more talent. But it /does/ mean you will be more successful than people with similar talent who do not dedicate their life.

In organizations this works the same: in the end not only talent, but also dedication decides who makes it to the top. And don't let the word "talent" fool you here. I do not mean the talent to care for the elderly, build good software or make beautiful things. I mean the talent /to make it to the top/!

So in the end, ruthless career tigers will bubble up the hierarchy and rule the rest of us. Not because they are good care-takers, engineers or even managers, but because they are better at and more dedicated to promoting their own position. Even well-meaning managers (fortunately most of them) are no match and will be stuck in mid-level management.

This may sound cynical, and maybe it is, but I find it gives me peace. I am an engineer and like to build useful and beautiful things. That means I can't compete with people who's only objective it is to move up. So, I won't. I try to stay away from people and situations that focus to much on their own position, and build my professional life in such a way that it is as satisfying and enjoyable as possible.

* PUBLISHED 10 minute org mode 101                                      :org:
CLOSED: [2020-02-02 za 08:38]

[[https://orgmode.org/][Org mode]] is a fast and effective tool to manage personal information, like notes, tasks, and references. It is also used for authoring and publishing blogs, books and academic papers. Org mode is part of [[https://www.gnu.org/software/emacs][Emacs]] and stores its data in plain-text files.

A versatile tool like org mode can be an intimidating beast. So, here is my org mode 101 to get you up to speed in 10 minutes flat[fn:To make this possible, I will stick to the essential commands, and leave customization for another post.].

** Editing

Org mode allows you to structure your files by using headings. Simply create a heading by beginning a line with an asterisk (\ast). Headings can be nested by adding asterisks (\ast\ast\ast for a level three heading). This way you can build an infinitely branching hierarchical tree of information. You can move headings around with =M-<arrow>= and whole subtrees with =S-M-<arrow>=.

Headings mark the beginning of a section. Within those sections can be metadata, text or further subtrees. The metadata is a whole new topic, so for now we will stick with text. The basic mark up of text looks like this:

#+BEGIN_SRC org
*Markup: *bold*, /italic/, _underlined_, +strikethrough+, =verbatim=, ~code~

- list
  + nested list
    1. Numbered list
#+END_SRC

Which shows as:

Markup: *bold*, /italic/, _underlined_, +strikethrough+, =verbatim=, ~code~

- list
  + other list
    1. Numbered list (cycle list types with =S-<left/right>=)

** Tasks

You can mark headers as tasks by using =S-<arrow>=. Left/right changes the todo state (shown by keywords like TODO and DONE), while up/down changes the todo priority (A for highest, C for lowest).

You can schedule a task using =C-c C-s= and set a deadline using =C-c C-d=.

** Tags

You can assign tags to headers using =C-c C-q=. A tag can be almost any text you like. I use:
- the projects the section belongs to starting with a =%= (like =%blog= and =%killer_app=),
- the person the section is relevant to starting with =@= (like =@alice= and =@bob=), or
- the context[fn:A concept from GTD] where I can work on the task starting with =#= (like =#office= and =#home)=.
By using special markers in tags, I can more easily find the headlines I am looking for.

** Capture

Org mode comes with a ton of its own [[https://orgmode.org/orgcard.pdf][key bindings]], and [[https://orgmode.org/guide/Introduction.html][advices]] to add three of your own. One of those is =C-c c= for [[https://orgmode.org/guide/Capture.html][Capturing]], which allows you to quickly jot down notes, so you can forget them, because org mode won't. All with minimal disruption of your workflow.

Once you're done entering text, you can store it in its default location using =C-c C-c= or refile and choose your own destination using =C-c C-w=.

** Agenda

After a while you will find that your tasks become unmanageable. So, one other custom binding org mode [[https://orgmode.org/guide/Introduction.html][advices]] is =C-c a= for [[https://orgmode.org/worg/org-tutorials/advanced-searching.html][Agenda]], which provides well-organized views of your tasks.

This is a life saver! It allows me to just dump all my tasks on one big heap and manage them through the agenda. I never bother to structure or cleanup my tasks. Searching is far more efficient than organizing[fn:See also [[https://karl-voit.at/2020/01/25/avoid-complex-folder-hierarchies/][public voit]]]!

** Categories

Each file and each header can belong to exactly one category. You can define the category by adding =#+CATEGORY:= at the start of a file or a property drawer below a header:
#+BEGIN_SRC org
:PROPERTIES:
:CATEGORY: Journal
:END:
#+END_SRC

Categories are an extra tool to structure your agenda views. I use these:
- PKB[fn:Personal Knowledge Base]
- Work
- Journal
- Links

** Further reading

Here are some references from beginner to advanced:
1. [[https://orgmode.org/worg/org-tutorials/org4beginners.html][Org4Beginners]] to get a quick overview of what org mode can do: editing, navigating
2. [[http://thagomizer.com/blog/2017/03/16/five-useful-org-mode-features.html][5 useful features]] with info about tables, tags, embedded code
3. [[http://emacslife.com/blog-posts/2014-01-13-tips-learning-org-mode-emacs.html][Emacs Life]] tips for learning org mode
5. [[https://orgmode.org/orgcard.pdf][RefCard]] a 2-page PDF with a load of key bindings ([[https://orgmode.org/orgcard.txt][text version]])
6. [[https://orgmode.org/guide/][Guide]] a compact version of the manual with all the essentials
7. [[https://karl-voit.at/2019/09/25/using-orgmode/][UOMF]] Using Org Mode Features
8. [[https://orgmode.org/worg/][Community]] documentation at Worg
9. [[https://orgmode.org/manual/][Manual]] everything you could ever want to know about org mode
10. [[http://ehneilsen.net/notebook/orgExamples/org-examples.html][Cookbook]] examples of advanced topics like diagrams and spreadsheets

* PUBLISHED Migrated to org                                        :org:meta:
CLOSED: [2020-02-02 zo 08:36]

I migrated the source of this blog to [[https://orgmode.org/][org mode]], using [[https://www.gatsbyjs.org/packages/gatsby-transformer-orga/][gatsby-transformer-orga]]. My source now lives in a single org mode file. Great!

* CANCELLED VSCode Shortcuts                            :coding:productivity:
CLOSED: [2020-12-16 za 19:43]
:PROPERTIES:
:ID:       5de52e07-002b-45d0-aa38-60c307480fb1
:END:

As [[/2020-01-01-about%20me][indicated]] I bounce back and forth between [[https://emacs.org][Emacs]] and [[https://code.visualstudio.com/][VSCode]] for coding.

Current editors like VSCode are just more modern. Many things are so much easier. And the main selling feature of Emacs, "/the [[https://www.gnu.org/software/emacs/emacs-paper.html][extensible, customizable]] editor/", is now also available in editors [[https://www.sublimetext.com/][like]] VSCode. You have a virtually unlimited choice of plugins and can relatively easily program your own. In Javascript. And not [[https://learnxinyminutes.com/docs/elisp/][elisp]][fn:1].

The one thing[fn:2] that keeps driving me back to Emacs is that the key bindings are in my muscle memory. To outsiders they seem archaic and mysterious, but to me they feel comfortable and homey. When I just /think/ of opening a file, my fingers want to go =Ctrl-X Ctrl-F=. And Emacs allows me to mostly stay away from the mouse, which saves me time and context switches.

Today I read [[https://dev.to/devmount/23-lesser-known-vs-code-shortcuts-as-gif-80][this post]] and it hit me that I could try to learn shortcuts in VSCode like I did in Emacs. I am sure that many of the things I do with the keyboard in Emacs can also be done in VSCode. So, I will try to add one shortcut every day to my repertoire.

To get me going, these are some useful resources:

- =Ctrl-K Ctrl-R= in VSCode opens the keyboard reference for your platform
- =Ctrl-K Ctrl-S= in VSCode opens the [[https://code.visualstudio.com/docs/getstarted/keybindings][keyboard shortcuts editor]] which initially shows the list of all defined key bindings
- =Ctrl-Shft-P= opens the searchable command palette, which shows keyboard shortcuts for every command
- Type =tips= in the command palette, and you get [[https://code.visualstudio.com/docs/getstarted/tips-and-tricks][Help, Tips & Tricks]]

Keys:

| Date           | Key binding               | Effect                  |
|----------------+---------------------------+-------------------------|
| <2020-01-17>   | =Ctrl-Alt-Shft NumDown=   | copy line to below      |
| <2020-01-20>   | =Alt-Down=                | move line down          |
| <2020-01-21>   | =Ctrl-R R=                | NPM rerun last script   |

[fn:1] Lisp is an elegant language, but just not for everyone.

[fn:2] Well... actually /one/ of the things, but that's for another
       post.

* PUBLISHED Node Streams                                      :node:research:
CLOSED: [2020-01-13 ma 19:41]

I am looking into a way to do ETL (Extract, Transform, Load) in Node. It seams to me that Streams are a very natural way to do this. However, Streams only seem to support simple pipelines of the form:

#+BEGIN_SRC js
    const fs = require('fs');
    const zlib = require('zlib');

    fs.createReadStream('./file.txt')                // read a file
      .pipe(zlib.createGzip())                       // zip it
      .pipe(fs.createWriteStream('./file.txt.gz'));  // and write it
#+END_SRC

In a diagram this would look like:

#+CAPTION: flow diagram of a pipe
[[file:pipe.png]]

But imagine I want to zip a file and mark it if it fails an expected checksum. In a diagram, that would look like:

#+CAPTION: flow diagram of a network
[[file:network.png]]

In order to do that, I would need Stream operations like =split= and =join=, but these don't seem to exist.

Let's figure out how to do this!

* PUBLISHED Setting up this blog                                  :meta:tech:
CLOSED: [2020-01-12 zo 19:40]

I have been looking for a platform to blog. It should support...

- templates,
- comments,
- tags,
- archive,
- feeds (RSS or Atom) and
- search.

On the technical side, I [[/2020-01-01-about%20me/][want]] it to...

- be open source,
- allow me to edit the posts locally in any editor I please (which
  requires flat-file input),
- support Markdown and (preferably) Org-mode input,
- maintain version history of the content,
- deploy to Github Pages (which requires output a site without
  backend)),
- be as free of tracking, ads or vendor lock-in as possible.

I have looked into e.g. [[https://getnikola.com/][Nikola]], [[https://orgmode.org/manual/Publishing.html][org-publish]], [[https://jekyllrb.com/][Jekyll]] and the likes, but never really liked
one.

So now I have decided to see if I can start one from scratch, based on
[[http://gatsbyjs.org/][Gatsby]]:

1. I started off with this [[https://www.freecodecamp.org/news/build-a-developer-blog-from-scratch-with-gatsby-and-mdx/][excellent tutorial]].
2. I added a [[https://github.com/marketplace/actions/deploy-to-github-pages][Github pages publish workflow]] (inspired by [[https://github.com/orgapp/gatsby-starter-orga/blob/master/.github/workflows/ci.yml][gatsby-starter-olga]]). I also needed to [[https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line][create a personal access token]] and [[https://help.github.com/en/actions/automating-your-workflow-with-github-actions/creating-and-using-encrypted-secrets][store it as a secret]].
3. I added comments, using [[https://utteranc.es/][utteranc.es]] through [[https://github.com/b6pzeusbc54tvhw5jgpyw8pwz2x6gs/react-utterances][react-utterances]].
4. I added tags, archive and pinned pages myself.
5. I added RSS feeds using [[https://www.gatsbyjs.org/packages/gatsby-plugin-feed/][gatsby-plugin-feed]].

Based on the Gatsby page about [[https://www.gatsbyjs.org/docs/adding-search/][adding search]] it seems you need some backend for search. As I don't want a backend, the blog will not have a search feature for now.

I have also decided against adding org-mode support with [[https://www.gatsbyjs.org/packages/gatsby-transformer-orga/][gatsby-transformer-orga]], because I couldn't figure out an elegant way to support multiple input formats and I am fine with Markdown for now.

My workflow is now really simple:

1. To add a post, I create a folder in =/posts= with an =index.mdx= file in it.
2. I edit =index.mdx= in Markdown.
3. I commit and push.
4. After a couple of minutes, Github has generated my new website.

Feel free to check [[https://github.com/randomrambler/dwim][Github]] for all the gory details.

* PUBLISHED Package management                                       :coding:
CLOSED: [2020-01-04 za 19:40]

In /IEEE Computer magazine/ of March 1998 the original developer or Tcl/TK, John Ousterhout, [[http://www.tcl.tk/doc/scripting.html][wrote]]:

#+BEGIN_QUOTE
Scripting languages are designed for /gluing/ applications; they use typeless approaches to achieve a higher level of programming and more rapid application development than system programming languages. Increases in computer speed and changes in the application mix are making scripting languages more and more important for applications of the future.
#+END_QUOTE

I think that more than 20 years later we can confirm that Ousterhout was right. Programming has been transformed from writing everything yourself from scratch, to finding the right components, configuring them and combining them with some code of your own. And, although strongly typed and compiled languages like Java and C# persist, scripting languages like Javascript and Python [[https://octoverse.github.com/#top-languages][top]] the [[https://insights.stackoverflow.com/survey/2019#most-popular-technologies][charts]].

When I learned to program (/oldtimer speaking/), there was no Internet. If I wanted to use code written by others, I bought a magazine and painstakingly copied the printed code into my trusted [[https://codeincomplete.com/posts/c64-manual-nostalgia/][C64]]. And when I say "copy", I do not mean =cp file.bas=, but [[https://en.wikipedia.org/wiki/Type-in_program][typing]] the code one character at a time. When I was really 'lucky' I had to type long lists of meaningless numbers representing machine code. The result would be blazing fast, but hardly ever worked, because typos were almost inevitable.

[[./type-in-listing.png]]
[[http://www.ourdigitalheritage.org/archive/playitagain/why-write-a-commodore-64-game-today/][src]]

To me, the biggest innovation in programming of the last decade is package managers like [[https://pipenv.kennethreitz.org/][pipenv]] and [[https://yarnpkg.com/][yarn]], which make finding, installing and maintaining packages a breeze. And to top it off, documentation has improved dramatically over the last couple of years.
* PUBLISHED About me                                           :meta:private:
CLOSED: [2020-01-01 wo 19:40]
:PROPERTIES:
:PINNED:   t
:END:

/Latest update: January 16, 2020/

I am a software engineer, living in the Netherlands. I was born almost 50 years ago.

I develop software; mostly websites, but also the occasional CLI or daemon. [[https://www.python.org/][Python]] has long been my go to programming language, but I find I am moving more and more towards [[https://developer.mozilla.org/en-US/docs/Web/JavaScript][Javascript]]. Lately I am even drawn to [[http://www.typescriptlang.org/][Typescript]].

I prefer /open technologies/: I use open source software (OSS) whenever I can. And practically the only times that I can't, involve working together with others on Microsoft Office documents. My preferred tools include:

- [[https://www.ubuntu.com/][Ubuntu]], but sometimes I need to work on Windows. Therefore, all my tools preferably work on both.
- I bounce back and forth between [[https://emacs.org][Emacs]] and [[https://code.visualstudio.com/][VSCode]] for code editing.
- [[https://git-scm.com/doc][Git]] for version management and [[https://github.com/otech-nl][Github]] for sharing my code, issue management, and (Kanban) boards.
- [[https://www.docker.com/][Docker]] for managing development environments when [[https://pipenv.kennethreitz.org/][pipenv]] or [[https://yarnpkg.com/][yarn]] are not enough.
- [[file:orgmode.org][org-mode]] and sometimes [[https://daringfireball.net/projects/markdown/syntax][Markdown]] for plain text editing.

Have a look at [[/2020-01-12-blog/][this]] blog post to find out how I
set up this blog.

* DRAFT Test post                                                      :meta:
:PROPERTIES:
:ID:       b5d76ebc-ac1f-4d9a-aaaf-68166835322f
:END:
#+date: 2099-12-31
#+published: nil
#+tags: [meta]

This is a test post. It normally shouldn't show in production.
