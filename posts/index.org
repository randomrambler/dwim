#+TITLE: DWIM
#+ORGA_PUBLISH_KEYWORD: PUBLISHED
#+TODO: DRAFT(d) | PUBLISHED(p) CANCELLED(c)


* DRAFT Head-voice vs. quiet-mind
:PROPERTIES:
:ID:       ca3a7f14-f4af-4a91-981b-f795b631a17e
:END:

http://esr.ibiblio.org/?p=8558

* DRAFT Goodbye, Clean Code — Overreacted

https://overreacted.io/goodbye-clean-code/


* DRAFT News                                                        :society:
Uit "alle mensen deugen": Ik ben nog opgevoed met de gedachte dat het nieuws goed is voor je ontwikkeling. Een betrokken burger zou regelmatig de krant moeten lezen en het journaal kijken. Hoe beter we het nieuws volgen, hoe beter we geïnformeerd zijn, hoe gezonder de democratie.

* DRAFT Emacs is no text editor | Eigenbahn blog                       :emacs:

https://www.eigenbahn.com/2020/01/12/emacs-is-no-editor

Emacs is stable. You can get back to it after years, and immediately be productive. That's why my alternative editor keeps changing (UltraEdit, Sublime, VSCode), but Emacs has been a recurring thing since the early nineties.

For instance, I was editing an extensive code comment lately, and my fingers just went =M-q= to word wrap the comment block. I hadn't done that since the years I read email with RMAIL (early nineties), but without thinking, the key combination happened.

Compared to Emacs, most text editors (like VSCode) are glorified typewriters.
Compared to Emacs, most word processors (like MS Word) are just text editors with formatting.
Emacs is a true text processing platform.

* DRAFT How to make impossible choices        :productivity:org:emacs:coding:

Life is full of impossible choices. In those cases I follow these conservative but practical rules:
- When in doubt, stay on the same road.
- If it's not broken, don't fix it.

Let me give you some examples:

** Emacs vs other editors

I keep bouncing back and forth between [[https://emacs.org][Emacs]] and other text editors (most recently: [[https://code.visualstudio.com/][VSCode]]) for coding.

Current editors like VSCode are just more modern. Many things are so much easier. And the main selling feature of Emacs, "the [[https://www.gnu.org/software/emacs/emacs-paper.html][extensible, customizable]] editor", is now also available in editors [[https://www.sublimetext.com/][like]] VSCode. You have a virtually unlimited choice of plugins and can relatively easily program your own. In Javascript. And not [[https://learnxinyminutes.com/docs/elisp/][elisp]] (Lisp is an elegant language, but just not for everyone).

One thing that keeps driving me back to Emacs is that the key bindings are in my muscle memory. To outsiders they may seem archaic and mysterious, but to me they feel comfortable and homey. When I just /think/ of opening a file, my fingers want to go =C-x C-f=. And Emacs allows me to mostly stay away from the mouse, which saves me time and context switches.

But, at the same time, that's also one of the major down-sides of Emacs: every time I switch to another application, my mind has to switch to other key bindings. All of a sudden the ubiquitous =C-x= and =C-c= of Emacs have become =cut= and =copy=. And when I hit =C-w= (=kill-region=) to cut a piece of text, instead I close a tab. This switching is an annoying mental effort and /very/ error prone. Of course, I am aware of [[https://www.gnu.org/software/emacs/manual/html_node/emacs/CUA-Bindings.html][CUA mode]] but I prefer to use every tool as it was intended.

But the killer app that currently drove me back to Emacs is [[/what-is-org-mode][Org mode]]. There is nothing comparable.

_Result_: For now, I am back using Emacs, but I can already feel the rising frustration with the lack of compatibility with other apps, so at some point I will probably change back.

** Literate coding or comments

As an org mode user, literate programming is all the rage, with [[https://orgmode.org/worg/org-contrib/babel/intro.html][org-babel]] to 'untangle'. Emacs configs in an org mode document [[https://www.google.com/search?q=org+mode+emacs+config][abound]] online. And they /do/ make for very nicely readable documents. So, I have long intended to try this approach but never came round to it.

In the end, the extra indirection and level of complexity added by literate programming need to be justified by some benefit. So, unless you are writing a book or blog posts, code comments are the easiest way to document code.

_Result_: I just add comments.

** Where to put stuff

Many things can (or should) be stored only once. For example, a book, a piece of code, or the contact information of your doctor. But to be able to find them, it may be useful to store them in different places. A book, for example, can be stored alphabetically by title, by author, or by subject. But if you have only one copy (and why shouldn't you), you can only store it in one place at a time.

Fortunaltely, indexing

** Programming language

[[https://www.python.org/][Python]] has long been my go to programming language, but I find I am moving more and more towards [[https://developer.mozilla.org/en-US/docs/Web/JavaScript][Javascript]]. Lately I am even drawn to [[http://www.typescriptlang.org/][Typescript]].

** Emacs completion framework

Completion makes life so much easier. On the command line first bash, but these days [[https://ohmyz.sh/][Oh My ZSH!]].

* DRAFT Software development is a craft                                  :coding:

It is not a science (yet)
Learn through master/apprentice

* DRAFT Yesterbox                                              :productivity:

https://yesterbox.com/

Slow cooking, slow communication

* PUBLISHED Emacs: Is it worth it?                   :emacs:org:productivity:
CLOSED: [2020-02-20 do 16:05]

[[https://www.reddit.com/r/emacs/comments/f61ipx/is_it_worth_it/][This Reddit post]] dares to ask the question if Emacs is worth it. Quite courageous in the =r/emacs= subreddit, if you ask me...

What we get is some refreshingly blunt replies:
- Org Mode will mostly just cause you to waste your life configuring it. It will never end, always presenting another way to be more efficient/clever. One day you will find yourself sharing your story in an Orgaholics Anonymous meeting while gripping your paper notebook.
- I'm watching 10+ year old YouTube videos of Emacs presentations trying to find what possible configurations I've missed
- Emacs and Org present great temptations for procrastination when you need to get work done
- "I am learning to limit that because it was getting in the way of getting things done." leads to "Ah yes, the addiction at its finest."

It's all /so/ relatable. Here I am, writing a blog post I am not being paid for, while I have a long lists of tasks with actual deadlines. Org mode makes it into a /beautiful/ and /manageable/ list, true, but I am /not/ working on it.

Then [[https://www.reddit.com/user/publicvoit/][publicvoit]] nails it by:
#+BEGIN_QUOTE
Everybody is procrastinating. Anybody who disagrees is either lying or she/he is not aware of doing X as procrastinating.
The good news here is that you seem to optimize your working environment while procrastinating.
#+END_QUOTE

And that's also true. Fortunately. Better yet, when you automate some part of your workflow, you do not just make that task easier, but you also improve your automation skills. This means that next time you want to automate something, that too will be easier, and less of an obstacle to make further improvements.

My pitfall is that I am tempted to tinker. I tend to optimize and optimize my code (or my workflow), until it is just too clever. Just as the Reddit post above, [[https://overreacted.io/goodbye-clean-code/][this]] blog post is also very relatable. Fortunately, these days I am aware of this, and signal I am doing it again earlier. I once read the following advice, which I have been trying to follow ever since:
#+BEGIN_QUOTE
Resist the urge to tinker.
#+END_QUOTE
I don't remember where I found it, but it may have been in [[https://en.wikipedia.org/wiki/The_Mythical_Man-Month][The Mythical Man-Month]] by Frederick Brooks.

I think at the moment I have struck an acceptable balance. In the past I have been known to spend many hours making Emacs more beautiful. A thankless challenge in many ways, because Emacs is many things, but beautiful is not one of them. So currently, I experiment with packages that help me /now/ (as opposed to with some task in the future). Moreover, I try to stick with what's available out of the box and with the default configuration as much as possible.

* PUBLISHED Emacs? Help!                                              :emacs:
CLOSED: [2020-02-15 za 17:37]

A powerful tool like Emacs can be intimidating for beginners. But actually, Emacs is very beginner-friendly, because it comes standard with a plethora of help features. In this post, I'll give some starting points, and show what help functions I use the most.

First, just start up a vanilla Emacs (use =emacs -q= to bypass any user configuration files, if necessary) and the startup screen provides you with some helpful entry points, like the Emacs manual and [[https://www.gnu.org/software/emacs/tour/][guided tour]]. Of course, you can find the same information, and much more, under the /Help/ menu item.

The manual that you can open from the startup screen teaches you some Emacs jargon, like how key bindings are defined. It provides an interactive introduction with exercises you can perform in the same buffer. It teaches you the Emacs-way to do things like navigate a document. To my taste its a bit dogmatic about that: I prefer arrow keys and PgUp/Dn to navigate, but the tutorial sticks to =C-v/M-v= and the likes.

The startup screen also contains a link to the Emacs manual, which introduces us to the wonderful world of [[https://www.gnu.org/software/texinfo/manual/info-stnd/html_node/index.html][Info]]. We'll come back to that later, when we discuss the =C-h= key. For now, let's assume that Info is like the web: hypertext with links. So, open the manual and have a look around. What I like to do every now and then, is page though the documents by just pressing the space bar repeatedly. This is like leafing through a book and never fails to uncover gems I didn't know yet.

Section 1 "The Organization of the Screen" introduces much Emacs jargon that may put off beginners. This section explains words like /frame/, /window/, /buffer/, /point/, /mode line/ and /mini buffer/, all essential to be able to use all other information that is available to us.

Then, when you actually start to use Emacs, the menu bar provides access to most common commands, including the key bindings that go with them for commands you find you need most often. /Please/ resist the urge to install all those shiny third-party packages for now, and first dig through all the features that Emacs ships with out of the box, like searching, bookmarks, email and version control. Also have a look at all you can customize through the /Options/ menu. But again, /please/ stick with the defaults at first. They have been selected based on years of experience, and more often than not make more sense that you might think at first (promise!).

Finally, I you ever wonder /How do I do X?:/ =C-h= is your friend.
- =C-h ?= shows all help command, including the ones I use most:
- =C-h a= (apropos) show commands matching a pattern
- =C-h k= describes a key
- =C-h f= describes a function (by default the function under point) and the keys associated with it
- =C-h v= describes a variable, its current value, its original value, and its possible values
- =C-h i= starts Info, which opens a whole library full of manuals, I don't believe you I will ever finish in this lifetime

Have fun exploring Emacs!

* PUBLISHED Work vs problems                                   :productivity:
CLOSED: [2020-02-11 di 20:59]

I distinguish between work and problems.

Work can be done by following well-known, accepted rules. It may not be easy, but you know from the start how hard it is and how much effort it takes. Work just takes time, energy and commitment. So, just do it already!

There are no predefined rules for problems. You have to figure them out as you go along. It's not even clear how to know which solution is best, because problems usually have multiple perspectives with (possibly conflicting) interests. Problems may even have multiple stakeholders. So you have to analyze the problem to come up with possible solutions, evaluate the solutions by all different criteria, and than choose on basis of incomplete information. And that's all /before/ you can start actually solving the problem itself.

The obvious trap here is that you can get stuck in the analysis/evaluation, because choosing is hard and often involves conflict. So my approach often is to just choose one option, fix the problem and deal with the consequences. Which may require me to get back to the drawing board to come up with a whole new solution. I am happy to solve a problem more than once, because it means you always have a solution in place (as imperfect as it may be), and it will gradually get better.

* PUBLISHED Backup your email! It's easy                    :productivity:it:
CLOSED: [2020-02-10 ma 11:39]

Email has become the core of corporate (and often private) communication. Most of us use it all day every day.

There used to be a time, where you downloaded your email and read it locally. But these days, email lives on a server somewhere. Which is A Good Thing, because we are mobile and this lets us read our email everywhere (which, in itself, is a mixed blessing at best).

But there's a downside: We now depend on the service providers. When their service is down, or we are off-line (the horror!) we don't have access to our email anymore. Or worse, if our provider goes out of business or just decides to discontinue its service, we may even loose our email permanently.

Fortunately, the solution is easy: back up your email. On Linux the most mentioned solutions are [[http://www.offlineimap.org/][offlineimap]] and [[http://isync.sourceforge.net/][mbsync]]. A little research shows many people choosing mbsync over offlineimap, so I decided to follow suit. With the help of [[http://fengxia.co.s3-website-us-east-1.amazonaws.com/mbsync%20mu4e%20email.html][this]] and [[https://ryanwhittingham.com/using-multiple-email-accounts-with-mu4e/][this]] post I had it set up without too many problems.

Then I watched over 20k (almost 10 years worth) of my emails being pulled in, which comes to almost 6GB. It's now all save and cosy on my local hard drive. Synchronizing takes just seconds and I can still also access my email in the cloud from my smart phone and tablet.

As a bonus, and not entirely by accident, I can now read my email in Emacs using [[https://www.djcbsoftware.nl/code/mu/mu4e.html][mu4e]]. But that's for another post.

* PUBLISHED What is Org mode                                            :org:
CLOSED: [2020-02-07 vr 09:23]

So I wrote about how to [[10 minute org mode 101][use]] Org mode, but only briefly discussed what it /is/:

#+BEGIN_QUOTE
Org mode is a fast and effective tool to manage personal information, like notes, tasks, and references. It is also used for authoring and publishing blogs, books and academic papers. Org mode is part of Emacs and stores its data in plain-text files.
#+END_QUOTE

That's not a lie, but it barely scratches the surface. I was listening to [[https://emacscast.org/episode_3/][Emacscast]] today, and the explanation by host Rakhim inspired this post.

Basically, I see Org mode as three parts:

- a markup language :: The markup language supports structuring with nested sections and formatting like for example Markdown. Unlike Markdown, and more like XML, org mode also supports meta data, like categories, tags, and properties
- an editor :: Org mode is part of Emacs, so when editing org mode, you can use all functions that Emacs provides. But it adds powerful features to manage complexity, like outlining, navigating, folding and tables.
- modules :: Org mode provides a myriad of modules out of the box, including, but definitely not limited to:
  - todos: Keep your task list with todo states, priorities, deadlines and scheduling.
  - agenda: Manage your tasks by sorting and filtering them in any way you can think of.
  - spreadsheet: Interactively calculate values in a table.
  - publish: Edit your content in org mode, and publish it as Markdown, HTML, PDF or EPUB out of the box, or [[https://github.com/kawabata/ox-pandoc][any other form]] via Pandoc.
  - literate programming: Execute code right in your document with Babel.
  - capture thoughts: With minimal disruption to your workflow.
  - time management: Estimate, register and report how you spend uour time.

As the markup is just plain text, you can edit org mode files in any text editor you like. This ensures you never loose access to your data. The editor is where org mode begins to distinguish itself: editors like [[https://github.com/vscode-org-mode/vscode-org-mode][VSCode]], [[https://github.com/jceb/vim-orgmode][Vim]] and [[https://packagecontrol.io/packages/orgmode][Sublime]] support only a small subset of the features you get when editing org mode in Emacs. But the modules are where org mode really starts to shine. They add such amazingly powerful features that they make org mode unlike any other tool I know.

The strength of these modules is that they are +integrated+ loosely coupled. By that I mean they have maximum cohesion and minimum dependency. And by that I mean that the modules form a suite where every tool works together with the others, but the do not /need/ each other. This way you can gradually add modules to get an ever richer experience and truly [[http://doc.norang.ca/org-mode.html][Organize Your Life In Plain Text!]]

* PUBLISHED Peter Principle for assholes                       :organisation:
CLOSED: [2020-02-06 do 08:38]

The [[https://en.wikipedia.org/wiki/Peter_principle][Peter Principle]] states:

#+BEGIN_QUOTE
  people in a hierarchy tend to rise to their "level of incompetence"
#+END_QUOTE

It boils down to this: when you are competent at your job, you are promoted until you're /not/ competent anymore.

But I think something more sinister is at play here. In [[http://www.dilbert.com/][The Dilbert Principle]] Scott Adams suggests that the main task of management is to "Eliminate the Assholes". However, my view is that management /are/ the assholes. Nothing personal, so let me explain.

We are all constantly working for (1) our own position and (2) the higher good. Working for our own position may mean making our work as enjoyable as possible, maximizing status/income/power, or anything that you want to achieve for yourself. The higher good is the reason your job exists in the first place: the business of your customers, some political ideal, or a charity.

Most people most of the time look for a middle ground between their own position and the higher good. They try to strike a balance where the one not does not harm the other. But sometimes this doesn't work and you have to make a choice. For example, if you stand up for an important but unpopular policy, it may help the higher good, but it may harm your position.

This also works in unexpected ways. For example, if you work late to provide a critical feature for your client before its deadline, you would think this would help both the higher good and your position. But the latter is rarely the case. We are often not rewarded for extra effort we put in. Why is this?

I think this is because some people do /not/ balance their own position and the higher good, but instead choose just one of these. In particular, some people focus exclusively on their own position, and work for their own promotion only. So in the contest for income, status or power, these people win from anyone who divide their focus between their position and the higher good.

It is just as in sports: to really make it to the top, you have to sacrifice everything and everyone and put all your effort into becoming the best you can be at your chosen sport. This doesn't mean success is guaranteed if you do that (in fact, chances are remote), because others who do the same may have more talent. But it /does/ mean you will be more successful than people with similar talent who do not dedicate their life.

In organizations this works the same: in the end not only talent, but also dedication decides who makes it to the top. And don't let the word "talent" fool you here. I do not mean the talent to care for the elderly, build good software or make beautiful things. I mean the talent /to make it to the top/!

So in the end, ruthless career tigers will bubble up the hierarchy and rule the rest of us. Not because they are good care-takers, engineers or even managers, but because they are better at and more dedicated to promoting their own position. Even well-meaning managers (fortunately most of them) are no match and will be stuck in mid-level management.

This may sound cynical, and maybe it is, but I find it gives me peace. I am an engineer and like to build useful and beautiful things. That means I can't compete with people who's only objective it is to move up. So, I won't. I try to stay away from people and situations that focus to much on their own position, and build my professional life in such a way that it is as satisfying and enjoyable as possible.

* PUBLISHED 10 minute org mode 101                                      :org:
CLOSED: [2020-02-02 za 08:38]

[[https://orgmode.org/][Org mode]] is a fast and effective tool to manage personal information, like notes, tasks, and references. It is also used for authoring and publishing blogs, books and academic papers. Org mode is part of [[https://www.gnu.org/software/emacs][Emacs]] and stores its data in plain-text files.

A versatile tool like org mode can be an intimidating beast. So, here is my org mode 101 to get you up to speed in 10 minutes flat. To make this possible, I will stick to the essential commands, and leave customization for another post.

** Editing

Org mode allows you to structure your files by using headings. Simply create a heading by beginning a line with an asterisk (\ast). Headings can be nested by adding asterisks (\ast\ast\ast for a level three heading). This way you can build an infinitely branching hierarchical tree of information. You can move headings around with =M-<arrow>= and whole subtrees with =S-M-<arrow>=.

Headings mark the beginning of a section. Within those sections can be metadata, text or further subtrees. The metadata is a whole new topic, so for now we will stick with text. The basic mark up of text looks like this:

#+BEGIN_SRC org
*Markup: *bold*, /italic/, _underlined_, +strikethrough+, =verbatim=, ~code~

- list
  + nested list
    1. Numbered list
#+END_SRC

Which shows as:

Markup: *bold*, /italic/, _underlined_, +strikethrough+, =verbatim=, ~code~

- list
  + other list
    1. Numbered list (cycle list types with =S-<left/right>=)

** Tasks

You can mark headers as tasks by using =S-<arrow>=. Left/right changes the todo state (shown by keywords like TODO and DONE), while up/down changes the todo priority (A for highest, C for lowest).

You can schedule a task using =C-c C-s= and set a deadline using =C-c C-d=.

** Tags

You can assign tags to headers using =C-c C-q=. A tag can be almost any text you like. I use:
- the projects the section belongs to starting with a =%= (like =%blog= and =%killer_app=),
- the person the section is relevant to starting with =@= (like =@alice= and =@bob=), or
- the context, a concept from GTD, where I can work on the task starting with =#= (like =#office= and =#home)=.
By using special markers in tags, I can more easily find the headlines I am looking for.

** Capture

Org mode comes with a ton of its own [[https://orgmode.org/orgcard.pdf][key bindings]], and [[https://orgmode.org/guide/Introduction.html][advices]] to add three of your own. One of those is =C-c c= for [[https://orgmode.org/guide/Capture.html][Capturing]], which allows you to quickly jot down notes, so you can forget them, because org mode won't. All with minimal disruption of your workflow.

Once you're done entering text, you can store it in its default location using =C-c C-c= or refile and choose your own destination using =C-c C-w=.

** Agenda

After a while you will find that your tasks become unmanageable. So, one other custom binding org mode [[https://orgmode.org/guide/Introduction.html][advices]] is =C-c a= for [[https://orgmode.org/worg/org-tutorials/advanced-searching.html][Agenda]], which provides well-organized views of your tasks.

This is a life saver! It allows me to just dump all my tasks on one big heap and manage them through the agenda. I never bother to structure or cleanup my tasks. Searching is far more efficient than organizing [[[https://karl-voit.at/2020/01/25/avoid-complex-folder-hierarchies/][src]]]!

** Categories

Each file and each header can belong to exactly one category. You can define the category by adding =#+CATEGORY:= at the start of a file or a property drawer below a header:
#+BEGIN_SRC org
:PROPERTIES:
:CATEGORY: Journal
:END:
#+END_SRC

Categories are an extra tool to structure your agenda views. I use these:
- Personal Knowledge Base
- Work
- Journal
- Links

** Further reading

Here are some references from beginner to advanced:
1. [[https://orgmode.org/worg/org-tutorials/org4beginners.html][Org4Beginners]] to get a quick overview of what org mode can do: editing, navigating
2. [[http://thagomizer.com/blog/2017/03/16/five-useful-org-mode-features.html][5 useful features]] with info about tables, tags, embedded code
3. [[http://emacslife.com/blog-posts/2014-01-13-tips-learning-org-mode-emacs.html][Emacs Life]] tips for learning org mode
5. [[https://orgmode.org/orgcard.pdf][RefCard]] a 2-page PDF with a load of key bindings ([[https://orgmode.org/orgcard.txt][text version]])
6. [[https://orgmode.org/guide/][Guide]] a compact version of the manual with all the essentials
7. [[https://karl-voit.at/2019/09/25/using-orgmode/][UOMF]] Using Org Mode Features
8. [[https://orgmode.org/worg/][Community]] documentation at Worg
9. [[https://orgmode.org/manual/][Manual]] everything you could ever want to know about org mode
10. [[http://ehneilsen.net/notebook/orgExamples/org-examples.html][Cookbook]] examples of advanced topics like diagrams and spreadsheets

* PUBLISHED Migrated to org                                        :org:meta:
CLOSED: [2020-02-02 zo 08:36]

I migrated [[/setting-up-this-blog][my setup]] of this blog to [[https://orgmode.org/][org mode]], using [[https://www.gatsbyjs.org/packages/gatsby-transformer-orga/][gatsby-transformer-orga]]. My source now lives in a single org mode file. Great!

My workflow is now really simple:

1. To add a post, I add a heading in my org file.
2. I change its status to =PUBLISHED= (org mode automatically records a timestamp).
3. I commit and push.
4. After a couple of minutes, Github has generated my new website.

* CANCELLED VSCode Shortcuts                            :coding:productivity:
CLOSED: [2020-12-16 za 19:43]
:PROPERTIES:
:ID:       5de52e07-002b-45d0-aa38-60c307480fb1
:END:

As [[/2020-01-01-about%20me][indicated]] I bounce back and forth between [[https://emacs.org][Emacs]] and [[https://code.visualstudio.com/][VSCode]] for coding.

Current editors like VSCode are just more modern. Many things are so much easier. And the main selling feature of Emacs, "/the [[https://www.gnu.org/software/emacs/emacs-paper.html][extensible, customizable]] editor/", is now also available in editors [[https://www.sublimetext.com/][like]] VSCode. You have a virtually unlimited choice of plugins and can relatively easily program your own. In Javascript. And not [[https://learnxinyminutes.com/docs/elisp/][elisp]] (an elegant language, but just not for everyone).

The one thing that keeps driving me back to Emacs is that the key bindings are in my muscle memory. To outsiders they seem archaic and mysterious, but to me they feel comfortable and homey. When I just /think/ of opening a file, my fingers want to go =Ctrl-X Ctrl-F=. And Emacs allows me to mostly stay away from the mouse, which saves me time and context switches.

Today I read [[https://dev.to/devmount/23-lesser-known-vs-code-shortcuts-as-gif-80][this post]] and it hit me that I could try to learn shortcuts in VSCode like I did in Emacs. I am sure that many of the things I do with the keyboard in Emacs can also be done in VSCode. So, I will try to add one shortcut every day to my repertoire.

To get me going, these are some useful resources:

- =Ctrl-K Ctrl-R= in VSCode opens the keyboard reference for your platform
- =Ctrl-K Ctrl-S= in VSCode opens the [[https://code.visualstudio.com/docs/getstarted/keybindings][keyboard shortcuts editor]] which initially shows the list of all defined key bindings
- =Ctrl-Shft-P= opens the searchable command palette, which shows keyboard shortcuts for every command
- Type =tips= in the command palette, and you get [[https://code.visualstudio.com/docs/getstarted/tips-and-tricks][Help, Tips & Tricks]]

Keys:

| Date         | Key binding           | Effect                |
|--------------+-----------------------+-----------------------|
| <2020-01-17> | =Ctrl-Alt-Shft NumDown= | copy line to below    |
| <2020-01-20> | =Alt-Down=              | move line down        |
| <2020-01-21> | =Ctrl-R R=              | NPM rerun last script |


* PUBLISHED Node Streams                                      :node:research:
CLOSED: [2020-01-13 ma 19:41]

I am looking into a way to do ETL (Extract, Transform, Load) in Node. It seams to me that Streams are a very natural way to do this. However, Streams only seem to support simple pipelines of the form:

#+BEGIN_SRC js
    const fs = require('fs');
    const zlib = require('zlib');

    fs.createReadStream('./file.txt')                // read a file
      .pipe(zlib.createGzip())                       // zip it
      .pipe(fs.createWriteStream('./file.txt.gz'));  // and write it
#+END_SRC

In a diagram this would look like:

#+CAPTION: flow diagram of a pipe
[[file:./pipe.png]]

But imagine I want to zip a file and mark it if it fails an expected checksum. In a diagram, that would look like:

#+CAPTION: flow diagram of a network
[[file:./network.png]]

In order to do that, I would need Stream operations like =split= and =join=, but these don't seem to exist.

Let's figure out how to do this!

* PUBLISHED Setting up this blog                                  :meta:tech:
CLOSED: [2020-01-12 zo 19:40]

I have been looking for a platform to blog. It should support...

- templates,
- comments,
- tags,
- archive,
- feeds (RSS or Atom) and
- search.

On the technical side, I [[/2020-01-01-about%20me/][want]] it to...

- be open source,
- allow me to edit the posts locally in any editor I please (which
  requires flat-file input),
- support Org-mode input,
- maintain version history of the content,
- deploy to Github Pages (which requires output a site without
  backend),
- be as free of tracking, ads or vendor lock-in as possible.

I have looked into e.g. [[https://getnikola.com/][Nikola]], [[https://orgmode.org/manual/Publishing.html][org-publish]], [[https://jekyllrb.com/][Jekyll]] and the likes, but never really liked one.

So now I have decided to see if I can start one from scratch, based on [[http://gatsbyjs.org/][Gatsby]]:

1. I started off with this [[https://www.freecodecamp.org/news/build-a-developer-blog-from-scratch-with-gatsby-and-mdx/][excellent tutorial]].
2. I added a [[https://github.com/marketplace/actions/deploy-to-github-pages][Github pages publish workflow]] (inspired by [[https://github.com/orgapp/gatsby-starter-orga/blob/master/.github/workflows/ci.yml][gatsby-starter-olga]]). I also needed to [[https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line][create a personal access token]] and [[https://help.github.com/en/actions/automating-your-workflow-with-github-actions/creating-and-using-encrypted-secrets][store it as a secret]].
3. I added comments, using [[https://utteranc.es/][utteranc.es]] through [[https://github.com/b6pzeusbc54tvhw5jgpyw8pwz2x6gs/react-utterances][react-utterances]].
4. I added tags, archive and pinned pages myself.
5. I added RSS feeds using [[https://www.gatsbyjs.org/packages/gatsby-plugin-feed/][gatsby-plugin-feed]].

Based on the Gatsby page about [[https://www.gatsbyjs.org/docs/adding-search/][adding search]] it seems you need some backend for search. As I don't want a backend, the blog will not have a search feature for now.

[[/migrated-to-org][Update Feb 2, 2020]]: I migrated to org mode.

Feel free to check [[https://github.com/randomrambler/dwim][Github]] for all the gory details.

* PUBLISHED Package management                                       :coding:
CLOSED: [2020-01-04 za 19:40]

In /IEEE Computer magazine/ of March 1998 the original developer or Tcl/TK, John Ousterhout, [[http://www.tcl.tk/doc/scripting.html][wrote]]:

#+BEGIN_QUOTE
Scripting languages are designed for /gluing/ applications; they use typeless approaches to achieve a higher level of programming and more rapid application development than system programming languages. Increases in computer speed and changes in the application mix are making scripting languages more and more important for applications of the future.
#+END_QUOTE

I think that more than 20 years later we can confirm that Ousterhout was right. Programming has been transformed from writing everything yourself from scratch, to finding the right components, configuring them and combining them with some code of your own. And, although strongly typed and compiled languages like Java and C# persist, scripting languages like Javascript and Python [[https://octoverse.github.com/#top-languages][top]] the [[https://insights.stackoverflow.com/survey/2019#most-popular-technologies][charts]].

When I learned to program (/oldtimer speaking/), there was no Internet. If I wanted to use code written by others, I bought a magazine and painstakingly copied the printed code into my trusted [[https://codeincomplete.com/posts/c64-manual-nostalgia/][C64]]. And when I say "copy", I do not mean =cp file.bas=, but [[https://en.wikipedia.org/wiki/Type-in_program][typing]] the code one character at a time. When I was really 'lucky' I had to type long lists of meaningless numbers representing machine code. The result would be blazing fast, but hardly ever worked, because typos were almost inevitable.

[[./type-in-listing.png]]
[[http://www.ourdigitalheritage.org/archive/playitagain/why-write-a-commodore-64-game-today/][src]]

To me, the biggest innovation in programming of the last decade is package managers like [[https://pipenv.kennethreitz.org/][pipenv]] and [[https://yarnpkg.com/][yarn]], which make finding, installing and maintaining packages a breeze. And to top it off, documentation has improved dramatically over the last couple of years.
* PUBLISHED About me                                           :meta:private:
CLOSED: [2020-01-01 wo 19:40]
:PROPERTIES:
:PINNED:   t
:END:

/Latest update: January 16, 2020/

I am a software engineer, living in the Netherlands. I was born almost 50 years ago.

I develop software; mostly websites, but also the occasional CLI or daemon. [[https://www.python.org/][Python]] has long been my go to programming language, but I find I am moving more and more towards [[https://developer.mozilla.org/en-US/docs/Web/JavaScript][Javascript]]. Lately I am even drawn to [[http://www.typescriptlang.org/][Typescript]].

I prefer /open technologies/: I use open source software (OSS) whenever I can. And practically the only times that I can't, involve working together with others on Microsoft Office documents. My preferred tools include:

- [[https://www.ubuntu.com/][Ubuntu]], but sometimes I need to work on Windows. Therefore, all my tools preferably work on both.
- I bounce back and forth between [[https://emacs.org][Emacs]] and [[https://code.visualstudio.com/][VSCode]] for code editing.
- [[https://git-scm.com/doc][Git]] for version management and [[https://github.com/otech-nl][Github]] for sharing my code, issue management, and (Kanban) boards.
- [[https://www.docker.com/][Docker]] for managing development environments when [[https://pipenv.kennethreitz.org/][pipenv]] or [[https://yarnpkg.com/][yarn]] are not enough.
- [[file:orgmode.org][org-mode]] and sometimes [[https://daringfireball.net/projects/markdown/syntax][Markdown]] for plain text editing.

Have a look at [[/setting-up-this-blog/][this]] blog post to find out how I set up this blog.

* DRAFT Test post                                                      :meta:
:PROPERTIES:
:ID:       b5d76ebc-ac1f-4d9a-aaaf-68166835322f
:END:
#+date: 2099-12-31
#+published: nil
#+tags: [meta]

This is a test post. It normally shouldn't show in production.
